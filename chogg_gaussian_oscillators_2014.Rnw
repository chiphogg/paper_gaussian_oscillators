\documentclass[12pt,letterpaper]{article}
\begin{document}
\title{Visualizing uncertain curves and surfaces via Gaussian Oscillators}
\author{Charles~R.~Hogg~III}
\date{August~2014}
\maketitle

<<global_setup, cache=FALSE, include=FALSE>>=
require(ggplot2)
require(knitr)
require(gridExtra)

source('interpolation.R')

# Smart caching.
opts_chunk$set(cache=TRUE, autodep=TRUE)

theme_set(theme_grey(base_size=12))

set.seed(1)
@

\section{Introduction}
\label{sec:introduction}

(What's the idea?  What am I trying to do?)

The present author is aware of two main approaches in the literature.

Historically, most animations have been based on \textit{interpolation}\footnote{Get Skilling and ESG references; cite them here.}.
A series of independent draws from the Gaussian are generated and displayed at regular time intervals; these are called the \textit{keyframes}.
The frames at intervening times are weighted averages of the nearest two keyframes.
The weighting favours the first keyframe at the beginning of the interval, and the second keyframe near the end, so that the curve or surface changes continuously from one keyframe to the next.
Figure \ref{fig:interpolation}(a) illustrates the idea for a simple 1-dimensional Gaussian using three possible interpolating families: \textit{linear}, \textit{cubic spline}, and \textit{trigonometric}.

<<interpolation_plots, include=FALSE>>=
quantiles <- c(0.1, 0.5, 0.9)
num.interpolated.curves <- 5e2  # Make it bigger later
num.points <- 500
num.keyframes <- 4
interpolation.caption <- sprintf(
    paste("Interpolation illustrated for a standard 1-D Gaussian.",
          "(a) A single set of normal draws interpolated by three methods.",
          "(b) Pointwise quantiles for interpolating %s random draws."),
    formatC(num.interpolated.curves, big.mark=',', format='fg'))

interp.matrix.functions <- list(Linear=InterpLinear,
                                Spline=InterpSpline,
                                Trigonometric=InterpTrig)

p.concept <- InterpolationConceptPlot(
    interp.matrix.functions=interp.matrix.functions,
    n.points=num.points,
    n.keyframes=num.keyframes)

p.interp <- InterpolationQuantilePlot(
    interp.matrix.functions=interp.matrix.functions,
    quantiles=quantiles,
    n.draws=num.interpolated.curves,
    n.points=num.points,
    n.keyframes=num.keyframes)
@

<<interpolation, cache=FALSE, echo=FALSE, fig.cap=interpolation.caption>>=
grid.arrange(p.concept,
             p.interp,
             ncol=1)
@


((Trigonometric interpolation (Skilling; ESG).  Use figure to show percentiles.))

((Great-circles by Hennig.  For the first time, smooth and keyframe-free.))

\section{Gaussian Oscillators}
\label{sec:gaussian_oscillators}

(Explain the idea of a Gaussian Oscillator.)

(Explain they are a specific kind of time-domain Gaussian processes, but there may be more/less efficient ways to compute them.)

(Note: Hennig's great circles are not quite GOs, because the 1-D Gaussians are not independent; constrained to have constant mean.)

\section{A New Way to Generate Animations}
\label{sec:a_new_way_to_generate_animations}

(Introduce my approach)

(Relationship to Fourier transforms)

(Mention non-looping version)

\section{Comparison}
\label{sec:comparison}

\subsection{Kinematic Properties}
\label{sub:kinematic_properties}

(Consider motion as a physical object; velocity and acceleration.)

\subsection{Statistical Properties}
\label{sub:statistical_properties}

<<ks_plots, include=FALSE>>=
# The number of Gaussian Oscillators of each type to construct.  Increasing
# this number gives more reliable density estimation.
num_oscillators <- 10000

# The number of equivalent independent normal draws to test.
equivalent_draws <- c(2, 10, 50)
names(equivalent_draws) <- equivalent_draws

# Utility function to compute the KS statistic on each column of a matrix.
KsOnColumns <- function(m) {
  apply(m, 2, function(v) ks.test(v, pnorm)$statistic)
}

RandomNormals <- function(n.rows, n.cols) {
  matrix(rnorm(n=n.rows * n.cols), nrow=n.rows)
}

# We want to create the desired number of copies of each oscillator.
# First, we'll do independent Gaussian draws as a reference point.
ks.independent <- lapply(equivalent_draws,
                         function(num) {
                           KsOnColumns(RandomNormals(num, num_oscillators))
                         })
# How many points to evaluate continuous timetraces at.  The higher this
# number, the more precision we have for *individual* oscillators' KS
# statistics.
num.continuous.points <- 1000
# Now we can compute the statistics for the Gaussian Oscillators (and a few
# more which aren't GOs).  Start by computing a matrix with enough normals for
# everything; we'll just take the top N rows to get N independent draws.
common.seed <- RandomNormals(max(equivalent_draws), num_oscillators)
KsForMethod <- function(matrix.function) {
  lapply(equivalent_draws,
         function(num) {
           KsOnColumns(
               matrix.function(
                   num, TimeSequence(num, num.continuous.points, loop=TRUE))
               %*% common.seed[1:num, ])
         })
}
ks.trig <- KsForMethod(InterpTrig)
ks.delocalized <- KsForMethod(DelocalizedMatrix)

ListToDataFrame <- function(L, name) {
  d <- cbind(melt(do.call(cbind.data.frame, L)), type=name)
  names(d)[which(names(d) == 'variable')] <- 'num.draws'
  names(d)[which(names(d) == 'value')] <- 'x'
  return (d)
}
ks.all <- rbind(
    ListToDataFrame(ks.independent, 'Independent Draws'),
    ListToDataFrame(ks.trig, 'Trigonometric Interpolation'),
    ListToDataFrame(ks.delocalized, 'Delocalized (this work)'))
ks.figure.caption <- sprintf(
    paste('How faithfully does each Gaussian Oscillator represent the normal',
          'distribution? This figure uses the Kolmogorov-Smirnov distribution',
          'to answer that question.  (Each curve is a histogram of %s draws.)',
          '(a) Independent draws from the normal distribution (which are not',
          'Gaussian Oscillators) provide a basis for comparison.  As expected,',
          'taking more draws shifts the distribution towards smaller values,',
          'indicating a better fit.',
          '(b), (c), and (d) show the Gaussian Oscillators for %d, %d, and %d',
          'draws, respectively, alongside the same number of independent',
          'draws.  Trigonometric interpolation is always more faithful than',
          'the same number of independent draws, but the delocalized',
          'oscillators this paper introduces are significantly better than',
          'both.'),
    formatC(num_oscillators, big.mark=',', format='fg'),
    equivalent_draws[1],
    equivalent_draws[2],
    equivalent_draws[3])
@

<<ks_figure, echo=FALSE, cache=FALSE, fig.cap=ks.figure.caption>>=
KsFigure <- function(i) {
  d <- ks.all[i, ]
  p <- (ggplot(data=d, aes(x=x, y=..density.., colour=type, linetype=num.draws))
        + geom_freqpoly(binwidth=diff(range(d$x))/60, size=1)
        + theme(legend.position='none')
        + scale_colour_brewer(palette='Set2')
        + scale_linetype_manual(values=setNames(c(1, 2, 4),
                                                equivalent_draws))
        )
}
grid.arrange(ncol=2,
             KsFigure(which(ks.all$type == 'Independent Draws')),
             KsFigure(which(ks.all$num.draws == 2)),
             KsFigure(which(ks.all$num.draws == 10)),
             KsFigure(which(ks.all$num.draws == 50)))
@

\subsection{Computational Properties}
\label{sub:computational_properties}

(How many random numbers does it take?)

\section{Future Work}
\label{sec:future_work}

\subsection{Animating non-Gaussian distributions}
\label{sub:animating_non_gaussian_distributions}

(``Nearly Gaussian'': time warping.)

Other challenging cases:

(Discrete distributions.)

((Obviously, we can't animate these continuously.))

((However, maybe special cases can kinda sorta work, e.g., Poisson/Anscombe transform.))

(Disconnected/thinly connected regions.)

((Maybe animate each mode/region separately.))

\subsection{Alternative time-domain covariance functions}
\label{sub:alternative_time_domain_covariance_functions}

(Compact support: endless exploration!)

(Challenging to do in R: no framebuf support.)

((However, could output javascript with d3.js!))

\section{Conclusions}
\label{sec:conclusions}

\end{document}

Ideas which need a home

(Looping vs. non-looping)
